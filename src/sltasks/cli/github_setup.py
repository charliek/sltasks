"""GitHub setup command for interactive configuration generation."""

import logging
import re
import shutil
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Any

import yaml

from ..github.client import GitHubAuthError, GitHubClient, GitHubClientError
from ..github.queries import GET_ORG_PROJECT, GET_PROJECT_ITEMS, GET_USER_PROJECT
from ..utils.slug import slugify_column_id
from .output import error, header, info, success

logger = logging.getLogger(__name__)

CONFIG_FILE = "sltasks.yml"

# YAML header for generated config (uses {default_repo} placeholder)
CONFIG_HEADER = """\
# sltasks GitHub Projects Configuration
#
# Generated by: sltasks --github-setup
# To regenerate: sltasks --github-setup [PROJECT_URL]
#
# === GitHub Provider Settings ===
#
# project_url: Full GitHub project URL
#   Formats: https://github.com/users/USER/projects/N
#            https://github.com/orgs/ORG/projects/N
#
# default_repo: Repository for creating new issues (owner/repo format)
#   Required when creating tasks from the TUI
#
# default_status: Initial Status field value for new issues
#   Must match a Status field option (e.g., "Backlog", "To Do")
#
# priority_field: (optional) GitHub project single-select field for priority
#   Maps field options to priority levels by position (first = lowest)
#   If not set, priority is read from issue labels instead
#
# featured_labels: (optional) Labels shown for quick assignment when editing
#   List labels you frequently use (e.g., "needs-review", "blocked")
#
# base_url: (optional) For GitHub Enterprise, set to your domain
#   Default: api.github.com
#
# include_prs: (optional) Include pull requests on the board (default: true)
# include_closed: (optional) Include closed issues (default: false)
# include_drafts: (optional) Include draft issues (default: false)
#
# === Type and Priority Configuration ===
#
# canonical_alias: The GitHub label name for write-back
#   When saving a task, this label is applied to the issue
#   Example: id: "bug" with canonical_alias: "type:bug"
#            -> GitHub label "type:bug" is used
#
# type_alias / priority_alias: Alternative label names for reading
#   Maps existing labels to sltasks types/priorities
#   Example: type_alias: ["defect"] -> "defect" label maps to this type
#
# === Label Setup Reminder ===
#
# Ensure type labels exist in your repository:
#   gh label create "type:feature" --color 0000FF --repo {default_repo}
#   gh label create "type:bug" --color FF0000 --repo {default_repo}
#   gh label create "type:task" --color FFFFFF --repo {default_repo}
#
# For priority labels (if not using priority_field):
#   gh label create "priority:low" --color 00FF00 --repo {default_repo}
#   gh label create "priority:medium" --color FFFF00 --repo {default_repo}
#   gh label create "priority:high" --color FFA500 --repo {default_repo}
#   gh label create "priority:critical" --color FF0000 --repo {default_repo}
#

"""

# Footer with optional settings (appended after YAML config)
OPTIONAL_FIELDS_FOOTER = """\

# === Optional GitHub Settings (uncomment to enable) ===
#
# Add these under the 'github:' section above:
#
#   base_url: github.mycompany.com  # For GitHub Enterprise
#   include_prs: false              # Exclude pull requests (default: true)
#   include_closed: true            # Show closed issues (default: false)
#   include_drafts: true            # Show draft issues (default: false)
#   allowed_repos:                  # Whitelist specific repositories
#     - owner/repo1
#     - owner/repo2
"""


@dataclass
class ProjectMetadata:
    """Metadata about a GitHub Project."""

    id: str
    title: str
    status_options: list[dict[str, str]]  # [{"id": "...", "name": "..."}]
    single_select_fields: dict[
        str, list[dict[str, str]]
    ]  # {"Priority": [{"id": ..., "name": ...}]}
    detected_repos: list[str]  # Repositories detected from project items


def parse_project_url(url: str) -> tuple[str, str, int] | None:
    """Parse a GitHub project URL.

    Supports:
        - https://github.com/users/USERNAME/projects/NUMBER
        - https://github.com/orgs/ORGNAME/projects/NUMBER
        - https://github.com/users/USERNAME/projects/NUMBER/views/VIEW

    Returns:
        Tuple of (owner_type, owner, number) or None if invalid.
        owner_type is 'user' or 'org'.
    """
    patterns = [
        # User project
        r"https?://github\.com/users/([^/]+)/projects/(\d+)",
        # Org project
        r"https?://github\.com/orgs/([^/]+)/projects/(\d+)",
    ]

    for pattern in patterns:
        match = re.match(pattern, url)
        if match:
            owner = match.group(1)
            number = int(match.group(2))
            owner_type = "user" if "/users/" in url else "org"
            return owner_type, owner, number

    return None


def fetch_project_metadata(
    client: GitHubClient, owner_type: str, owner: str, number: int
) -> ProjectMetadata | None:
    """Fetch project metadata from GitHub.

    Returns:
        ProjectMetadata or None if project not found.
    """
    # Select query based on owner type
    query = GET_USER_PROJECT if owner_type == "user" else GET_ORG_PROJECT
    key = "user" if owner_type == "user" else "organization"

    try:
        data = client.query(query, {"owner": owner, "number": number})
    except GitHubClientError as e:
        logger.error("Failed to fetch project: %s", e)
        return None

    project = data.get(key, {}).get("projectV2")
    if not project:
        return None

    # Extract fields
    status_options: list[dict[str, str]] = []
    single_select_fields: dict[str, list[dict[str, str]]] = {}

    for field in project.get("fields", {}).get("nodes", []):
        name = field.get("name")
        options = field.get("options")

        if options is not None:
            # Single-select field
            field_options = [{"id": opt["id"], "name": opt["name"]} for opt in options]
            if name == "Status":
                status_options = field_options
            else:
                single_select_fields[name] = field_options

    # Detect repositories from project items
    detected_repos = detect_repositories(client, project["id"])

    return ProjectMetadata(
        id=project["id"],
        title=project["title"],
        status_options=status_options,
        single_select_fields=single_select_fields,
        detected_repos=detected_repos,
    )


def detect_repositories(client: GitHubClient, project_id: str) -> list[str]:
    """Detect repositories from project items.

    Returns list of unique repository names (owner/repo format).
    """
    repos: set[str] = set()

    try:
        data = client.query(GET_PROJECT_ITEMS, {"projectId": project_id})
        items = data.get("node", {}).get("items", {}).get("nodes", [])

        for item in items:
            content = item.get("content", {})
            if content and "repository" in content:
                repo = content["repository"].get("nameWithOwner")
                if repo:
                    repos.add(repo)
    except GitHubClientError:
        logger.debug("Could not fetch project items for repository detection")

    return sorted(repos)


def find_priority_fields(metadata: ProjectMetadata) -> list[str]:
    """Find potential priority fields in the project.

    Returns field names that look like priority fields.
    """
    priority_keywords = ["priority", "severity", "urgency", "importance"]
    found = []

    for field_name in metadata.single_select_fields:
        if any(kw in field_name.lower() for kw in priority_keywords):
            found.append(field_name)

    return found


def generate_columns_config(status_options: list[dict[str, str]]) -> list[dict[str, str]]:
    """Generate columns config from Status options."""
    columns = []
    for opt in status_options:
        col_id = slugify_column_id(opt["name"])
        columns.append({"id": col_id, "title": opt["name"]})
    return columns


def generate_priorities_config(
    field_options: list[dict[str, str]] | None,
) -> list[dict[str, str]]:
    """Generate priorities config from field options or defaults.

    Options are mapped by position: first option = lowest priority.
    """
    default_priorities = [
        {"id": "low", "label": "Low", "color": "green"},
        {"id": "medium", "label": "Medium", "color": "yellow"},
        {"id": "high", "label": "High", "color": "orange1"},
        {"id": "critical", "label": "Critical", "color": "red"},
    ]

    if not field_options:
        return default_priorities

    # Map GitHub options to priorities by position
    colors = ["green", "yellow", "orange1", "red", "magenta"]
    priorities = []

    for i, opt in enumerate(field_options):
        priority_id = slugify_column_id(opt["name"])
        color = colors[i] if i < len(colors) else colors[-1]
        priorities.append(
            {
                "id": priority_id,
                "label": opt["name"],
                "color": color,
            }
        )

    return priorities


def generate_config(
    project_url: str,
    default_repo: str,
    columns: list[dict[str, str]],
    priorities: list[dict[str, str]],
    default_status: str | None = None,
    priority_field: str | None = None,
    task_root: str = ".tasks",
) -> dict[str, Any]:
    """Generate the full sltasks config dictionary."""
    config: dict[str, Any] = {
        "provider": "github",
        "task_root": task_root,
        "github": {
            "project_url": project_url,
            "default_repo": default_repo,
        },
        "board": {
            "columns": columns,
            "types": [
                {"id": "feature", "canonical_alias": "type:feature", "color": "blue"},
                {"id": "bug", "canonical_alias": "type:bug", "color": "red"},
                {"id": "task", "canonical_alias": "type:task", "color": "white"},
            ],
            "priorities": priorities,
        },
    }

    # Add optional GitHub fields
    if default_status:
        config["github"]["default_status"] = default_status
    if priority_field:
        config["github"]["priority_field"] = priority_field

    return config


def generate_yaml(config: dict[str, Any], default_repo: str) -> str:
    """Generate YAML string from config dictionary.

    Args:
        config: The config dictionary to serialize
        default_repo: Repository name to substitute in header examples
    """
    # yaml.dump returns str when stream is None (which is our case)
    yaml_content = yaml.dump(
        config, default_flow_style=False, sort_keys=False
    )  # pyrefly: ignore[bad-assignment]
    header = CONFIG_HEADER.format(default_repo=default_repo)
    return header + yaml_content + OPTIONAL_FIELDS_FOOTER  # pyrefly: ignore[unsupported-operation]


def prompt_input(prompt: str, default: str | None = None) -> str:
    """Prompt for user input with optional default."""
    if not sys.stdin.isatty():
        return default or ""

    if default:
        print(f"{prompt} [{default}]: ", end="", flush=True)
    else:
        print(f"{prompt}: ", end="", flush=True)

    user_input = input().strip()
    return user_input if user_input else (default or "")


def prompt_choice(prompt: str, options: list[str], default: int = 0) -> int:
    """Prompt user to choose from numbered options.

    Returns the index of the chosen option.
    """
    if not sys.stdin.isatty():
        return default

    print(f"\n{prompt}")
    for i, opt in enumerate(options):
        marker = "*" if i == default else " "
        print(f"  {marker}[{i + 1}] {opt}")

    while True:
        print(f"Enter choice (1-{len(options)}) [{default + 1}]: ", end="", flush=True)
        user_input = input().strip()

        if not user_input:
            return default

        try:
            choice = int(user_input)
            if 1 <= choice <= len(options):
                return choice - 1
        except ValueError:
            pass

        print(f"  Invalid choice. Enter 1-{len(options)}.")


def prompt_yes_no(prompt: str, default: bool = False) -> bool:
    """Prompt for yes/no confirmation."""
    if not sys.stdin.isatty():
        return default

    default_str = "Y/n" if default else "y/N"
    print(f"{prompt} [{default_str}]: ", end="", flush=True)
    user_input = input().strip().lower()

    if not user_input:
        return default

    return user_input in ("y", "yes")


def prompt_write_action(config_path: Path) -> str:
    """Prompt for write action: write, print, or cancel.

    Returns: 'write', 'print', or 'cancel'
    """
    if not sys.stdin.isatty():
        return "print"

    exists = config_path.exists()
    if exists:
        print(f"\nConfig file exists: {config_path}")
        print("  [w] Overwrite (backup will be created)")
    else:
        print(f"\nConfig will be written to: {config_path}")
        print("  [w] Write config file")

    print("  [p] Print to stdout only")
    print("  [c] Cancel")

    while True:
        print("Choose action [w/p/c]: ", end="", flush=True)
        user_input = input().strip().lower()

        if user_input in ("w", "write"):
            return "write"
        if user_input in ("p", "print"):
            return "print"
        if user_input in ("c", "cancel"):
            return "cancel"

        print("  Invalid choice. Enter w, p, or c.")


def run_github_setup(project_root: Path, project_url: str | None = None) -> int:
    """Run the interactive GitHub setup command.

    Args:
        project_root: Path to project root where sltasks.yml will be created
        project_url: Optional project URL (prompts if not provided)

    Returns:
        Exit code (0 = success, 1 = error)
    """
    header("GitHub Projects Setup")
    print()

    # Step 1: Get project URL
    if not project_url:
        project_url = prompt_input(
            "Enter GitHub project URL (e.g., https://github.com/users/USER/projects/1)"
        )

    if not project_url:
        error("Project URL is required")
        return 1

    # Parse URL
    parsed = parse_project_url(project_url)
    if not parsed:
        error(f"Invalid project URL: {project_url}")
        info("Expected format: https://github.com/users/USER/projects/NUMBER")
        info("            or: https://github.com/orgs/ORG/projects/NUMBER")
        return 1

    owner_type, owner, number = parsed
    info(f"Project: {owner}/{number} ({owner_type})")

    # Step 2: Authenticate
    try:
        client = GitHubClient.from_environment()
    except GitHubAuthError as e:
        error(str(e))
        return 1

    # Step 3: Fetch project metadata
    print("\nFetching project metadata...")
    with client:
        metadata = fetch_project_metadata(client, owner_type, owner, number)

    if not metadata:
        error("Project not found or not accessible")
        info("Check that the URL is correct and you have access to the project")
        return 1

    success(f"Found project: {metadata.title}")

    # Step 4: Display detected Status columns
    if not metadata.status_options:
        error("Project has no Status field with options")
        info("GitHub Projects require a Status field for column mapping")
        return 1

    print("\nDetected columns from Status field:")
    for opt in metadata.status_options:
        col_id = slugify_column_id(opt["name"])
        print(f"  • {opt['name']} → {col_id}")

    columns = generate_columns_config(metadata.status_options)

    # Step 5: Prompt for priority field
    priority_field: str | None = None
    priority_options: list[dict[str, str]] | None = None

    priority_fields = find_priority_fields(metadata)
    if priority_fields:
        print("\nDetected potential priority fields:")
        options = [*priority_fields, "(none - use labels)"]
        choice = prompt_choice("Select priority field:", options, default=0)

        if choice < len(priority_fields):
            priority_field = priority_fields[choice]
            priority_options = metadata.single_select_fields.get(priority_field)
            success(f"Using priority field: {priority_field}")
        else:
            info("Using labels for priority (default behavior)")
    else:
        info("No priority field detected. Using labels for priority.")

    priorities = generate_priorities_config(priority_options)

    # Step 6: Prompt for default status
    print("\nSelect default status for new issues:")
    status_names = [opt["name"] for opt in metadata.status_options]
    default_idx = prompt_choice("Default status:", status_names, default=0)
    default_status = status_names[default_idx]
    success(f"Default status: {default_status}")

    # Step 7: Detect or prompt for default repository
    default_repo: str = ""
    if metadata.detected_repos:
        print("\nDetected repositories from project items:")
        options = [*metadata.detected_repos, "(enter manually)"]
        choice = prompt_choice("Select default repository:", options, default=0)

        if choice < len(metadata.detected_repos):
            default_repo = metadata.detected_repos[choice]
        else:
            default_repo = prompt_input("Enter default repository (owner/repo)")
    else:
        default_repo = prompt_input("Enter default repository (owner/repo)")

    if not default_repo:
        error("Default repository is required")
        return 1

    success(f"Default repository: {default_repo}")

    # Step 8: Generate config
    config = generate_config(
        project_url=project_url,
        default_repo=default_repo,
        columns=columns,
        priorities=priorities,
        default_status=default_status,
        priority_field=priority_field,
    )

    yaml_content = generate_yaml(config, default_repo)

    # Step 9: Preview and prompt to write
    print("\n" + "=" * 60)
    print("Generated configuration:")
    print("=" * 60)
    print(yaml_content)
    print("=" * 60)

    config_path = project_root / CONFIG_FILE
    action = prompt_write_action(config_path)

    if action == "cancel":
        info("Setup cancelled")
        return 1

    if action == "print":
        info("Config printed above. Copy and paste to save.")
        return 0

    # Step 10: Write file
    if config_path.exists():
        # Create backup
        backup_path = config_path.with_suffix(".yml.bak")
        shutil.copy(config_path, backup_path)
        info(f"Backup created: {backup_path}")

    config_path.write_text(yaml_content)
    success(f"Config written: {config_path}")

    # Create task directory if it doesn't exist
    task_dir = project_root / ".tasks"
    if not task_dir.exists():
        task_dir.mkdir(parents=True)
        success(f"Created directory: {task_dir}/")

    print("\nSetup complete! Run 'sltasks' to start.")
    return 0
